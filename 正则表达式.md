## 正则表达式

正则表达式主要用来对文本的复杂处理

大部分编程语言、数据库、文本编辑器、开发环境都支持正则表达式！

**定义：** 正如其名字一样，描述了一个规则，通过这个规则可以匹配一类字符串

**开发中使用正则表达式的流程：**

- 分析所要匹配的数据，写出测试用到典型数据
- 在工具软件中进行匹配测试
- 在程序中调用通过测试的正则表达式

#### 正则表达式语法：

##### 普通字符：

字母、数字、汉字、下划线、没有特殊定义的标点符号

##### 转义字符：

\n,\t,\\\,\^......

##### 标准字符集合（大写相反）：

\d：0-9

\w：任意一个字母或者数字或者下划线

\s：空格、制表符、换行符

.：小数点可以匹配任意一个字符

#### 自定义字符集合：

-[]方括匹配方式，能够匹配方括号里**任意一个**字符

[ab5@]：匹配 a,b,5,@之一

[^ abc]：匹配a,b,c之外任意一个字符

[f-k]：匹配 "f" - "k" 之间分任意一个字母

[^ A-F0-3]：匹配 "A" - "F","0" - "3" 之外的任意一个字符



**注意：**正则表达式的特殊符号，被包含到中括号中，则失去意义

除了 ^,-

标准字符集合，除了小数点外，若被包含于中括号，自定义字符集合将包含该集合

[\\d.\\-+]：将匹配数字、小数点、+、-



##### 量词：

{n}：重复n次

{m,n}：表达式至少重复m次，最多重复n次

{m,}：表达式至少重复m次

?：相当于{0，1}

+：相当于{1，}

*：相当于{0，}

匹配次数中的贪婪模式（匹配字符越多越好，默认）

匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后加 ？）

#### 字符边界

^：与字符串开始的地方匹配

$：与字符串结束的地方匹配

\b：匹配一个单词边界



#### 匹配模式：

ignorecase：忽略大小写模式

​	默认忽略大小写

singleline：单行模式

​	整个文本看作一个字符串

multiline：多行模式

​	每行都是一个字符串



#### 选择组和分组：

|：或

()：捕获组

(?:Expression)：非捕获组



#### 反向引用(\\nnn)：



#### 预搜索（零宽断言）：

只进行子表达式的匹配，不计入最终的匹配结果，是零宽度

这个位置应该符合某个条件。判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符，是对位置的匹配

(?=exp)：断言自身出现的位置的后面能匹配表达式exp

(?<=exp)：断言自身出现的位置的前面能匹配表达式exp

(?!exp)：断言此位置的后面不能匹配表达式exp

(?<!exp)：断言此位置的前面不能匹配表达式exp



#### 电话号码验证：

- 电话号码由数字和 ”-“ 构成
- 电话号码为 7 到 8 位
- 若有区号，区号为3或者4位，首位是0
- 区号用 ”-“ 和其他部分隔开
- 移动电话号码为11位
- 11位第一位和第二位为 13、15、18



#### 常用的正则表达式列表

![image-20210103114034316](C:\Users\vipp\AppData\Roaming\Typora\typora-user-images\image-20210103114034316.png)`



#### Java中使用：

```java
package cn.imut;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Test {
    public static void main(String[] args) {
        //字符串中：asfsdf23323，是否符合指定的正则表达式：\w+

        //表达式对象
        Pattern p = Pattern.compile("\\w+");

        //创建Matcher对象
        Matcher m = p.matcher("asfsdf&&23323");

        //尝试将整个字符序列与该模式匹配
        boolean yesOrNo = m.matches();

        //该方法扫描输入的序列，查找与该模式匹配的下一个子序列
        boolean b = m.find();

        String s = m.replaceAll("#");
        System.out.println(s);
        System.out.println(yesOrNo);
    }
}

```

