## Java并发编程的艺术

### 一、并发编程的挑战

并发编程的目的是为了让程序运行得更快，但是，**并不是启动更多的线程就能让程序最大限度地并发执行。**

在进行并发编程时，如果希望通过多线程执行任务让程序运行得更快，会面临非常多的挑战！

**比如：上下文切换问题、死锁问题、受限于硬件和软件的资源限制问题等等**

#### 1.1 上下文切换

**单核处理器也支持多线程执行代码！**CPU通过给每个线程分配CPU时间片来实现这个机制。

时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，**使我们感觉多个线程是同时进行的，时间片一般是几十毫秒**

CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。

**所以任务从保存到再加载的过程就是一次上下文切换！**

（相当于阅读英文书时，发现不会的单词，只能打开词典查询，查询之前需要记住第几页第几行，查询完事后再回到那里）

**上下文切换会影响多线程的执行速度！**

***因为 上下文切换 所以，并行未必就有串行速度快！！！！！！！***

**所以只能减少上下文切换，其中方法有：无锁并发编程、CAS算法、使用最少线程和使用协议！**

- **无锁并发编程**

  多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些方法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据

- **CAS算法**

  Java的Atomic包使用CAS算法来更新数，而不需要加锁

- **使用最少线程**

  避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态

- **协议**

  在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

#### 1.2 死锁

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程

**产生死锁的四个必要条件：**

- **互斥条件**
- **请求和保持条件**
- **不剥夺条件**
- **环路等待条件**

**实际中避免产生死锁的几种常见方法：**

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
- 尝试使用定时锁，使用lock.tryLock（timeout）来代替使用内部锁机制
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

#### 1.3 资源限制的挑战

资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源

**其中硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU的处理速度，软件资源限制有数据库的连接数和socket连接数等**

在并发编程中，将代码速度加快的原则是将代码中串行的部分变成并发执行，**但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会变慢，因为增加了上下文切换和资源调度的时间**

（一段程序使用多线程下载处理数据，造成CPU使用率100%，则几个小时都无法完成任务，改成单线程，反而一个小时可以搞定）

**对于硬件资源限制，可以考虑用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机上运行，而对于软件资源限制，则可以考虑使用资源池将资源复用**

### 二、Java并发机制的底层实现原理

Java代码在编译后会变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令在CPU上执行，Java中所使用的并发机制依赖于JVM的实现和CPU的指令

#### 2.1 Volatile的应用

**在多线程并发编程中 synchronized 和 volatile 都扮演者重要的角色**，volatile是轻量级的 synchronized，它在多处理器开发中保证了共享变量的 **“可见性”！**

**可见性**：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值

**如果Volatile变量修饰符使用的恰当的话，它比 synchronized 的使用和执行成本更低，因为它不会引起线程上下文的切换和调度**

如果一个字段被声明成volatile，Java 线程内存模型确保所有线程看到这个变量的值是一致的

**Volatile保证可见性的过程：**

有 volatile 变量修饰的共享变量进行**写操作**时，会多出一条汇编代码

```java
instance = new Singleton();			//instance是 valatile变量

...... : lock ....
```

Lock前缀的指令在多核处理器下会引发两件事情

- 将当前处理器缓存行的数据写回到系统内存
- 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效（缓存一致性！）

#### 2.2 synchronized 的实现原理与应用

Java中的每一个对象都可以作为锁：

- 普通同步方法：锁是当前实例对象
- 静态同步方法：锁是当前类的Class对象
- 同步方法块：锁是Synchonized括号里配置的对象

